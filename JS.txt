
3.사용법
-주의할점 :
    (방법1)


    *(방법2)*
    1.
    2.
    3.
4. 주석
    - HTML : <!-- 주석내용 -->
    - CSS : /* 주석내용 */
    - JS : /* 여러줄 주석내용 */
           // 한줄 주석내용 
[ 기본 필수 용어 ]
    1. 데이터 ( Data / 자료 ) : 사실이나 값을 그대료 나타낸 객관적인 자료
   
    2. 리터럴 : 프로그래밍 언어(JS/JAVA/PY/C)에서 소스코드(작성한 코드)에 직접 표현한 값
       -> 왜? 컴퓨터는 0과1(2진수) 밖에 모른다?? 긱 프로그램언어 회사들은 0과1로 조합한 미리 조합한 미리 만들어지 단어가 필요하다.
       -> JS는 'a'를 모른다.
       -> 개발자가 사용할 수있다록 미리 정해진 값듣을 넣어놨다.( 상수=수정할수 없는 고정값 ) 
       -> 종류 : 9(숫자), a(문자), true(참),
       -> 프로그램밍 언어 회사에서 종류를 정한다. < 자료의타입/종류(자료형) >
    
    3. 자료형 : 프로그램언어에서 자료들을ㅇ 분류하는 방법
       -> 왜? 데이터를 처리하는데 효율적으로 하기 위해서 : <분리수거>
       -> 각 프로그램언어 별로 다르다.

[ JS 자료형 ]
    1. 숫자형 ( Number )  : 10 , 3.14
    2. 문자형 ( String )  : " 큰 따옴표 " 또는 ' 작은 따옴표' 감싼 자료
    3. 불리언 ( Boolean ) : true 또는 false  *대문자 주의
    4. 배열 ( Array )     : [ 자료, 자료, 자료 ] 중가로 안에 , 쉼표로 구분하여 여러 자료들을 감싼 자료
    5. 객체 ( Object )    :{ 속성명 : 자료, 속셩명 : 자료 } 중괄호 안에, 쉼표 구분하여 이름과 값이 한쌍을 이루는 자료
    6. 특수 : 
      - underfined : 자료가 할당되지 않은 상태
      - null : 자료가 존재하지 않음

* 생각해 보기 1
    [ 10 , 'A' , "사과", 3.14 ]
    위 코드에서 자료는 몇개? 5개 ( 10 , 'A' , "사과", 3.14 , [ ] )

* 생각해 보기 2
    [ { 이름 : "김현수" } , 'A' ,  3.14 ]    
     위 코드에서 자료는 몇개? 5개 ( "김현수", { } , 'A' ,  3.14 , [ ] )
     위 코드에서 리터럴은 몇개? 3개 ( "김현수" , 'A' ,  3.14 )
** 미리 정해지 기능이 포함된 특수문자/문자열 : 키워드
    [ ] , { } , console , Number, String, if, for 등등

[ 변수와 상수 ] ; 하나의 자료를 저장하는 메모리 공간
    1. 변수 *수정가능
        let 변수명 = 자료;
    2. 상수 *수정불가능
        const 변수명 = 자료;
[ 출력함수 ]                    
    1. console.log( 출력할자료 또는 변수명 ) : 브라우저의 개발자도구 console탭 출력
    2. alert( 출력할자료 또는 변수명 )       : 브라우저의 알침창 출력
[ 입력함수 ]    
    1. confirm( "메시지" )    : [확인][취소] 알림창, true 또는 false 반환
        let 변수명 = comfirm( );
    2. prompt( "메시지" )     : 텍스트 입력 창, 입력받은 텍스트 반환
        let 변수명 = prompt( );

[ 문자열 : 템플릿 리터럴 ] : 문자열과 변수 또는 식 연결하는 표현
    방법1) "문자열" + 변수명 + "문자열"
   * 방벙2)* ` 문자열 ${ 변수명 } 문자열`
[ 문자열 : 이스케이프 문자 ] : \백슬래시 이용한 특수 기호  

[ 배열 ]
    1. 여러 자료들을 순서대로 저장하는 *자료*
    2. 인덱스 : 배열내 자료들이 저장된 자료들의 순서번호 *0번부터 시작된다*
    3. 사용법
        (1) 선언 : let/const 변수명 = [ 자료, 자료, 자료 ]
        (2) 호출 : 변수명 or 변수명[ 인덱스 ]
        (3) 수정 : 변수명 = [ 새로운배열 ] or 변수명[ 인덱스 ] = 새로운값
        (4) 배열내 자료 총개수(길이) : 변수명.length
        
[ 배열 : 자주 사용되는 함수 ]    
    1. 변수명.push( 새로운 값 ) : 배열내 새로운 요소 추가
    2. 변수명.splice( 인덱스, 개수 ) : 배열내 지정한 인덱스부터 개수 요소 삭제
    3. 변수명.indexOf( 찾을값 ) : 배열내 '찾을값' 존재하는 인덱스 번호 반환, 없으면 -1 반환

[ 자료의 형변환 ]    
    1. 자동 타입변환
        (1) "문자열" * 1   : "문자열" -> 숫자형 변환,
        (2) "문자열" + 숫자형 :  "문자열"+숫자형  -> 문자열 변환
    2. 수동 타입변환
        (1) Number( )  : 문자열 -> 숫자형
        (2) parseInt( ) : 문자열 -> 숫자형(정수)
        (3) parsefloat( ) : 문자열 -> 숫자형(실수)
        (4) String( ) : 그외타입 -> 문자열
        (5) Boolean( ) : 문자열 -> 논리형

[ 연산자 ]        
    1. 산술연산자 :
    2. 연결연산자 : +연결
    3. 비교연산자 : >초과 <미만 >=이상 <=이하 ==같다 !=같지않다 ===/!==강력비교(타입까지 같다/같지않다)
    4. 논리연산자 : &&이면서 ||이거나 !부정
    5. 대입연산자 : =대입 , +=더한후 대입 , -=
    6. 증감연산자 : ++변수명, 변수명++, --변수명, 변수명--
    7. 삼항연산자 : 조건 ? 참 : 거짓, (중첩)조건1 ? 참1 : 조건2 ? 참 : 거짓

[ 조건문 ] : 특정한 조건의 논리(true/false) 결과에 따라서 명령어들을 처리
    1. if(조건) 참일때코드
    2. if(조건){ 참일때코드; }
    3. if(조건){ 참일때코드; }
        else{ 거짓일때코드; }
    4. if(조건1){ 참1일때 코드; }
       else if(조건2){ 참2일때코드; }
       else if(조건3){ 참3일때코드; }
       else{ 거짓일때코드; }
    5. if( 조건A ){
            if( 조건B ){ }
            else{ }
       }else{
            if( 조건B ){ }
            else{ }
       }

[ 반복문 ] : 특정한 조건의 논리 결과가 true 일때 명령어들을 반복 처리.
    1. for( 초기값 ; 조건문 ; 증감식 ){
            명령어 (코드);
    }
    2. 실행순서 : (1)초기값 -> (2)조건문 true -> (3) 명령어 -> (4)증감식
                              (5)조건문 true -> (3) 명령어 -> (4)증감식     
                              (5)조건문 true -> (3) 명령어 -> (4)증감식 
                              ~~반복~~
                              (5)조건문 false -> 반복문 종료
    * 주의할점 : 조건이 true 일때만 실행되므로 조건식과 증감식 관계가 무조건 true 일때 무한루프
   ( 3. break , continue )
    3. 배열/리스트 과 반복문 관계
        (1) 배열의 인덱스는 자료들을 0부터 순서대로 저장, 1씩 증가된 번호를 부여
        (2) 마지막 인덱스 : 변수명.length - 1
            for(let index = 0 ; index <= 변수명.length -1 ; index++ ){
                변수명[index];
            }
    4. for 중첩 : 일반적으로 행과 열 관계일때는 *행* 먼저 for 문 작성한다.<구구단>
        for(  ){
            for(  ){  }
        }
        * 주의할 점 : 상위 for 문의 1번 반복될때 하위 for 문은 전체 반복된다.
        예] 구구단 : 단마다 곱출력, 곱마다 단 출력 (선택사항이나, 첫번째가 관례적)
            2x1  2x2  2x3   2x4
            3x1  3X2  3X3   3X4
            4X1  4X2  4X3   4X4
            -> for( 단 ){  for( 곱 ) { }  } 2x1 -> 2x2 -> 2x3 -> 2x4
            -> for( 곱 ){  for( 단 ) { }  } 
    5. 반복문 제어 키워드
        (1) continue : 가장 가까운 for{}의 증감식 흐름 이동
        (2) break : 가장 가까운 for{}의 탈출/종료 흐름 이동
        (3) for( ; ; ) : 무한루프

[ 프로그래밍 관점 ]
    - 프로그래밍  구성하기 위한 접근 방식
    1. 절차지향 프로그래밍, C언어(구조체)
        (1) 함수(절차) 이용한 순서가 정해진 작업
        (2) 코드가 위에서 아래로 순차적으로 실행 , 단순하다.

    2. 객체지향 프로그래밍, JAVA/JS/PYTHON/C++
        (1) 객체(데이터/기능)을 *하나로 묶어서* 처리 작업, <사람> ---> <AI>
        (2) 코드의 재사용, 확장, 복잡하다.

[ 객체 ]        
    1. 정의

    2. 생활속 객체란 ? 모두( 물리적개념, 논리적개념 : 어떠한 대상을 정의[데이터/기능] 가능한 것 )

        ---> 개발자(주체자) 관점에서 컴퓨터속(객체)를 만든다.

[ JS 객체 ]        
    1. 종류
        (1) 클래스기반의 객체 : class(객체 만들기 위한 틀/설계도) *자바에서는 필수
        (2) 클래스가 없는 객체 : { }
    2. 배열과 객체 차이점
        (1) 배열 :
            [ ] , 인덱스 , 자료순서 있다. , 여러 목록
        (2) 객체 :
            { } , 속성명 , 자료순서 없다. , 하나의 정보
    *주의할 점 : 변수는 배열과 객체 자료를 1개 저장하는 메모리 공간 
        const var1 = [ 10 , 'hello' ]           --자료 2개를 저장하는 배열 자료 1개를 변수에 저장
        const var2 = { props1 : 10 , props : 'hello' }  - 자료2개를 속성으로 구분하여 객체 자료 1개를 변수에 저장
        -> 변수 vs 자료( 자료형 : 숫자/문자열/불리언/특수/배열/객체 )     
        -> *정보를 만들때는 객체화하고, 동일한 정보(객체)들을 여러개 묶을때는 배열*
    3. 사용법
        (1) 객체 선언 : 속성명과 자료를 한쌍으로 엔트리(entry)라고 하고, (쉼표)구분하여 여러개 엔트리 {}를 감싼
            { 속성명 : 자료1 , 속성명 : 자료2 , }
            *속성명(properties) : 하나의 객체에서 중복 불가능,  특수문자를를 포함한 경우는 "" 또는 ''로 감싼다.
            *자료(value) : 리터럴(숫자/문자열/블리언), 배열, 객체, 함수
        (2) 객체도 *하나*자료로써 변수에 대입될수있다.

        (3) 객체호출
            객체전체                    : 변수명
            객체내 특정한 속성값1           : 변수명.속성명
            객체내 특정한 속성값2           : 변수명['속성명']
            관련함수
                -> Object.keys(변수명)      :객체내 모든 속성명(key)를 배열로 반환
                -> Object.values(변수명)    :객체내 모든 자료(values)를 배열로 반환
                -> Object.entries(변수명)   :객체내 모든 엔트리(entries)를 배열로 반환.
        (4) 객체내 속성 다루기
            속성추가        : 변수명.속성명 = 자료
            속성값 수정     : 변수명.속성명 = 자료
            속성삭제        : delete 변수명.속성명
            속성확인        : '찾을속성명' in 변수명 , 찾을속성명이 존재하면 true/false   
            *서로 다른 의미들의 자료들은 객체로 묶어주고(행) , 동일한 의미의 자료들을 배열로 묶는다.(표/ 객체의 집합의 의미인가)
            배열 
[ 배열과 객체 ]
    - [ { } , { } , { } ] : 배열내 여러개 객체 이뤄진 형식
        예] 학생1 = 

    - 배열내 모든 객체 조회
        for( let index = 0 ; index <= 배열변수.length - 1  ; index++ ){
            let 객체 = 배열변수[index]
        }
        예] 특정한 배열에서 원하는 값을 찾으시오. ---> for 사용
            for( let i = 0 ; i <= 학생목록.length - 1 ; i++  ){
                if( 학생목록[i].나이 >= 40 ){ }
            }
    - 변수는 특징 :  { }안에서 선언(let변수/const상수)된 변수는 { } 밖으로 나갈수없다./ { } 안으로 들어갈수있다. <지역변수>
        -> 왜? 지역변수 장점 : 특정한 범위내 에서만 사용 --> 범위 벗어나면 변수는 사라진다. --> 메모리 효율성증대
        let A = 1;
        for( let index = 0 ; index <= 학생목록.length - 1 ; index++ ){
            let B = 2;
            console.log( index ) //[O] 
            console.log( B )//[O] 
            console.log( A ) //[O] 
        }
        console.log( index );   // [X] for 안에서 선언된 index 변수이므로 호출불가능(오류)
        console.log( B );       // [O] for 안에서 선언된 B변수 이므로 호출불가능(오류)
        console.log( A );       // [O]
[ 함수 ] : 이벤트/행동       
    1. 정의 : 특정한 { }중괄호 안에 미리 정의된 코드/명령어
    2. 목적 :
        (1)재사용
        (2)매개변수에 따른 서로 다른 실행 결과
        (3)매개변수/지역변수는 함수가 실행되면서 할당되고 종료되어서 (자동)사라진다.
            -> 힘수 *실행중*에만 변수 사용한다.
    3. 사용법
        (1) 함수 (정의/선언) 만든다.
            function 함수명( 매개변수, 매개변수 .... ){ }
        (2) 함수 (사용)호출한다.
            함수명( 인자값, 인자값 ... );
    4. 주요 키워드
        (1) 매개변수 : 함수호출시 함수안으로 들어오는 자료/값 저장하는 변수, 행동X
        (2) 실행문/로직{ } : 함수 호출될때 처리되는 코드/명령어들
        (3) 반환값 : 함수 종료될때 호출한 곳으로 반환/리턴되는 값, 행동X, 무조건 자료1개
    5. 선언하는 방법
        function 함수명( 매개변수 ){
            다양한 코드들;
            return 반환값
        }
    6. 사용/호출하는 방법
        (1) JS파일에서 호출하는 방법 (재사용여부에 따라)
            함수명( 인자값 );   정해진 매개변수에 따라 인자값 , 저장X
            let 결과 = 함수명();    함수실행후 반환값을 변수에 저장O
        (2) HTML파일에서 호출하는 방법
            <마크업 이벤트속성명="함수명()">    HTML에서 이벤트가 발생하면 정해진 함수가 실행            

- 변수는 하나의 자료 저장 : let 변수명 = 자료;
- 함수는 
[ DOM 객체 ] : document(HTML) object(객체) model(표준)
    1. 정의 : 문서객체표준 , HTML 마크업들을 객체처럼 다루기 *객체는 속성(property)과 함수(function)포함
    2. 내장객체 : document
    3. 주요속성과 함수
        (1)document.querySelector('선택자');    : HTML 마크업 객체 반환 함수, 반환값 : 객체1개
        (2)document.querySelectorAll('선택자');     : HTML 마크업 객체 반환 함수, 반환값 : 배열1개(객체 여러개)
            * 선택자는(CSS와 동일) 1. 마크업명  2. .클래스명   3. #id명  ,  >
        (3) (마크업객체).innerHTML          : <마크업>과 **여기** </마크업>사이에 HTML문자열대입
            사용불가능한 마크업 : 혼자열고 혼자 닫는 마크업들
            document.querySelectorAll('선택자').innerHTML
        (4) (마크업객체).value          : <마크업 value="**여기**' />에 자료 대입/호출
            사용가능 마크업 : <input /> , < select > , <textarea>
        (5) (마크업객체).style          : <마크업 style="**여기**' />에 css문법 대입/호출
        (6) (마크업객체).src            : <마크업 src="**여기**' />에 파일 경로 대입/호출
        (7)(마크업객체).classList
           (마크업객체).classList.add('클래스명')       : 지정 마크업에 클래스 추가
           (마크업객체).classList.remove('클래스명')    : 지정 마크업에 클래스 삭제
           (마크업객체).classList.toggle('클래스명')    : 지정 마크업에 클래스 추가 혹은 (존재하면) 삭제
           (마크업객체).classList.contains('클래스명')  : 지정 마크업에 클래스 존재여부 true/false 반환값
        (8)(마크업객체).remove()           


